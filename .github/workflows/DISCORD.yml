name: GitHub Auto Tag & Release with Discord Notification

on:
  push:
    branches: [ "master", "development" ]
  workflow_dispatch:

permissions:
  contents: write  # Ensures GitHub Actions can push tags and create releases

jobs:
  tag_and_release:
    runs-on: ubuntu-latest
    outputs:
      NEW_TAG: ${{ steps.versioning.outputs.NEW_TAG }}
      PLAIN_TEXT: ${{ steps.load_markdown.outputs.PLAIN_TEXT }}  # Pass Markdown content
    steps:

      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Ensure full history

      - name: Fetch Latest Tag and Determine Next Version
        id: versioning
        run: |
          git fetch --tags
          LATEST_TAG=$(git tag -l "v*-${LABEL}" --sort=-v:refname | head -n 1 | tr -d '\r')

          if [[ -z "$LATEST_TAG" ]]; then
            NEW_TAG="v0.1.0-${LABEL}"
          else
            if [[ "$LATEST_TAG" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)-${LABEL}$ ]]; then
              MAJOR="${BASH_REMATCH[1]}"
              MINOR="${BASH_REMATCH[2]}"
              PATCH="${BASH_REMATCH[3]}"
            else
              echo "Error: Could not parse latest tag '$LATEST_TAG'"
              exit 1
            fi

            PATCH=$((PATCH + 1))
            NEW_TAG="v$MAJOR.$MINOR.$PATCH-${LABEL}"
          fi

          echo "NEW_TAG=$NEW_TAG" >> $GITHUB_ENV
          echo "::set-output name=NEW_TAG::$NEW_TAG"

      - name: Load README.md Content (First 800 Characters)
        id: load_markdown
        run: |
          if [[ -f README.md ]]; then
            MARKDOWN_CONTENT=$(head -c 800 README.md | sed -e 's/#//g' -e 's/\*\*//g' -e 's/`//g')
            PLAIN_TEXT="$MARKDOWN_CONTENT\n\nTo continue reading, visit: https://github.com/${{ github.repository }}/blob/master/README.md"
          else
            PLAIN_TEXT="README.md could not be loaded. To view documentation, visit: https://github.com/${{ github.repository }}"
          fi

          delimiter=$(openssl rand -hex 6)
          echo "PLAIN_TEXT<<${delimiter}" >> $GITHUB_ENV
          echo "$PLAIN_TEXT" >> $GITHUB_ENV
          echo "${delimiter}" >> $GITHUB_ENV
          echo "::set-output name=PLAIN_TEXT::$PLAIN_TEXT"

  notify_discord:
    runs-on: ubuntu-latest
    needs: tag_and_release
    steps:

      - name: Send GitHub Event Notification to Discord
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_MASTER_URL }}
          REPO: ${{ github.repository }}
          TIMESTAMP: ${{ github.event.head_commit.timestamp }}
          NEW_TAG: ${{ needs.tag_and_release.outputs.NEW_TAG }}
          PLAIN_TEXT: ${{ needs.tag_and_release.outputs.PLAIN_TEXT }}
        run: |
          echo "Sending Discord notification for tag: $NEW_TAG"  # Debugging step

          JSON_PAYLOAD=$(jq -n --rawfile markdown_text <(echo "$PLAIN_TEXT") \
            --arg timestamp "$TIMESTAMP" \
            --arg repo "$REPO" \
            --arg tag "$NEW_TAG" \
            '{
              "username": "GitHub Bot",
              "avatar_url": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png",
              "embeds": [
                {
                  "title": "ðŸš€ New Release: \($tag)",
                  "description": "A new release has been created for the repository.",
                  "fields": [
                    {
                      "name": "ðŸ“… Timestamp",
                      "value": $timestamp,
                      "inline": false
                    },
                    {
                      "name": "ðŸ“‚ Repository",
                      "value": "[\($repo)](https://github.com/\($repo))",
                      "inline": false
                    },
                    {
                      "name": "ðŸ“œ Documentation Preview",
                      "value": $markdown_text,
                      "inline": false
                    },
                    {
                      "name": "ðŸ·ï¸ Tag",
                      "value": "\($tag)",
                      "inline": false
                    }
                  ]
                }
              ]
            }')

          echo "JSON Payload being sent to Discord:"
          echo "$JSON_PAYLOAD" | jq .  # Debugging

          curl -H "Content-Type: application/json" -X POST -d "$JSON_PAYLOAD" "$DISCORD_WEBHOOK_URL"
